// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Js_types = require("bs-platform/lib/js/js_types.js");
var Repromise = require("@aantron/repromise/src/js/repromise.js");
var Result$ReduxSerialEffects = require("./Result.bs.js");
var Helpers$ReduxSerialEffects = require("./Helpers.bs.js");

function getJsEffect(effect) {
  return effect[0];
}

function createResultAction(result, effect) {
  var jsEffect = effect[0];
  if (result.tag) {
    return jsEffect.resultActionCreator(true, result[0]);
  } else {
    return jsEffect.resultActionCreator(false, result[0]);
  }
}

function getResultActionCreator(effect) {
  var match = effect[0].resultActionCreator;
  if (match !== undefined) {
    return createResultAction;
  }
  
}

function createAsyncRunResultPromise(effectResultPromise) {
  return Repromise.Rejectable[/* catch */7]((function (err) {
                return Repromise.resolved(/* Error */Block.__(1, [err]));
              }), Repromise.Rejectable[/* map */5]((function (res) {
                    return /* Ok */Block.__(0, [res]);
                  }), Repromise.Rejectable[/* fromJsPromise */10](effectResultPromise)));
}

function run(effect) {
  var result = Result$ReduxSerialEffects.try_((function (param) {
          return effect[0].run();
        }));
  if (result.tag) {
    return /* SyncResult */Block.__(0, [/* Error */Block.__(1, [result[0]])]);
  } else {
    var match = Helpers$ReduxSerialEffects.classifyValueOrPromise(result[0]);
    if (match.tag) {
      return /* AsyncResult */Block.__(1, [createAsyncRunResultPromise(match[0])]);
    } else {
      return /* SyncResult */Block.__(0, [/* Ok */Block.__(0, [match[0]])]);
    }
  }
}

function runResultToPromise(runResult) {
  if (runResult.tag) {
    return runResult[0];
  } else {
    var effectResult = runResult[0];
    if (effectResult.tag) {
      return Repromise.resolved(/* Error */Block.__(1, [effectResult[0]]));
    } else {
      return Repromise.resolved(/* Ok */Block.__(0, [effectResult[0]]));
    }
  }
}

function validateEffect(effect) {
  var match = Js_types.classify(effect);
  if (typeof match === "number" || match.tag !== 3) {
    Js_exn.raiseTypeError("Invalid effect object");
  } else {
    var runType = Js_types.classify(effect.run);
    var isQueuedType = Js_types.classify(effect.isQueued);
    var resultActionCreatorType = Js_types.classify(effect.resultActionCreator);
    if (typeof runType === "number" || !(runType.tag === 2 && typeof isQueuedType === "number" && isQueuedType < 2)) {
      Js_exn.raiseTypeError("Invalid effect object");
    } else if (typeof resultActionCreatorType === "number") {
      switch (resultActionCreatorType) {
        case 2 : 
        case 3 : 
            break;
        default:
          Js_exn.raiseTypeError("Invalid effect object");
      }
    } else if (resultActionCreatorType.tag !== 2) {
      Js_exn.raiseTypeError("Invalid effect object");
    }
    
  }
  return effect;
}

function isImmediateEffect(effect) {
  if (effect.tag) {
    return false;
  } else {
    return true;
  }
}

function isQueuedEffect(effect) {
  return !isImmediateEffect(effect);
}

function toVariant(effect) {
  var match = effect.isQueued;
  if (match) {
    return /* Queued */Block.__(1, [effect]);
  } else {
    return /* Immediate */Block.__(0, [effect]);
  }
}

function subscriberResultToEffects(subscriberResult) {
  if (subscriberResult !== undefined) {
    return List.map(toVariant, List.map(validateEffect, $$Array.to_list(subscriberResult)));
  } else {
    return /* [] */0;
  }
}

exports.getJsEffect = getJsEffect;
exports.createResultAction = createResultAction;
exports.getResultActionCreator = getResultActionCreator;
exports.createAsyncRunResultPromise = createAsyncRunResultPromise;
exports.run = run;
exports.runResultToPromise = runResultToPromise;
exports.validateEffect = validateEffect;
exports.isImmediateEffect = isImmediateEffect;
exports.isQueuedEffect = isQueuedEffect;
exports.toVariant = toVariant;
exports.subscriberResultToEffects = subscriberResultToEffects;
/* Repromise Not a pure module */
