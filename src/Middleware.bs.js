// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Repromise = require("@aantron/repromise/src/js/repromise.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Store$ReduxSerialEffects = require("./Store.bs.js");
var Effect$ReduxSerialEffects = require("./Effect.bs.js");
var Result$ReduxSerialEffects = require("./Result.bs.js");
var Transition$ReduxSerialEffects = require("./Transition.bs.js");
var Subscribers$ReduxSerialEffects = require("./Subscribers.bs.js");
var PromiseQueue$ReduxSerialEffects = require("./PromiseQueue.bs.js");

function dispatchResultAction(store, effect, result) {
  var match = Effect$ReduxSerialEffects.getResultActionCreator(effect);
  if (match !== undefined) {
    return Store$ReduxSerialEffects.dispatch(store, Curry._2(match, result, effect));
  } else {
    return Repromise.resolved(/* Ok */Block.__(0, [/* () */0]));
  }
}

function executeEffect(store, effect) {
  var runResult = Effect$ReduxSerialEffects.run(effect);
  if (runResult.tag) {
    var downstreamPromise = Repromise.andThen((function (result) {
            if (result.tag) {
              var error = result[0];
              dispatchResultAction(store, effect, /* Error */Block.__(1, [error]));
              return Repromise.resolved(/* Error */Block.__(1, [error]));
            } else {
              return dispatchResultAction(store, effect, /* Ok */Block.__(0, [result[0]]));
            }
          }), runResult[0]);
    return /* tuple */[
            runResult,
            downstreamPromise
          ];
  } else {
    var downstreamPromise$1 = dispatchResultAction(store, effect, runResult[0]);
    return /* tuple */[
            runResult,
            downstreamPromise$1
          ];
  }
}

function getFirstRunResultErrorIfExists(runResults) {
  var maybeError = Result$ReduxSerialEffects.getFirstError(List.map((function (runResult) {
              if (runResult.tag) {
                return /* Ok */Block.__(0, [/* () */0]);
              } else {
                var match = runResult[0];
                if (match.tag) {
                  return /* Error */Block.__(1, [match[0]]);
                } else {
                  return /* Ok */Block.__(0, [/* () */0]);
                }
              }
            }), runResults));
  if (maybeError !== undefined) {
    return /* Error */Block.__(1, [Caml_option.valFromOption(maybeError)]);
  } else {
    return /* Ok */Block.__(0, [/* () */0]);
  }
}

function runImmediateEffects(store, effects) {
  return getFirstRunResultErrorIfExists(List.map((function (prim) {
                    return prim[0];
                  }), List.map((function (param) {
                        return executeEffect(store, param);
                      }), effects)));
}

function executeQueuedEffects(store, resolve, effects) {
  if (effects) {
    var promiseTuples = List.map((function (param) {
            return executeEffect(store, param);
          }), effects);
    Repromise.Rejectable[/* catch */7]((function (error) {
            Curry._1(resolve, /* Error */Block.__(1, [error]));
            return Repromise.resolved(/* () */0);
          }), Repromise.Rejectable[/* relax */0](Repromise.map((function (resultList) {
                    var match = Result$ReduxSerialEffects.getFirstError(resultList);
                    if (match !== undefined) {
                      return Curry._1(resolve, /* Error */Block.__(1, [Caml_option.valFromOption(match)]));
                    } else {
                      return Curry._1(resolve, /* Ok */Block.__(0, [/* () */0]));
                    }
                  }), Repromise.all(List.map((function (prim) {
                            return prim[1];
                          }), promiseTuples)))));
    return Repromise.map((function (resultList) {
                  var match = Result$ReduxSerialEffects.getFirstError(resultList);
                  if (match !== undefined) {
                    return Curry._1(resolve, /* Error */Block.__(1, [Caml_option.valFromOption(match)]));
                  } else {
                    return /* () */0;
                  }
                }), Repromise.all(List.map(Effect$ReduxSerialEffects.runResultToPromise, List.map((function (prim) {
                              return prim[0];
                            }), promiseTuples))));
  } else {
    Curry._1(resolve, /* Ok */Block.__(0, [/* () */0]));
    return Repromise.resolved(/* () */0);
  }
}

function scheduleExecution(addToQueue, store) {
  var match = Repromise.make(/* () */0);
  var gate = match[0];
  var match$1 = Repromise.make(/* () */0);
  var resolveSchedulePromise = match$1[1];
  Curry._1(addToQueue, (function (queuePromise) {
          return Repromise.andThen((function (param) {
                        return executeQueuedEffects(store, resolveSchedulePromise, param);
                      }), Repromise.andThen((function (param) {
                            return gate;
                          }), queuePromise));
        }));
  return /* tuple */[
          match$1[0],
          match[1]
        ];
}

function queueAndRunEffects(addToQueue, store, effects) {
  var match = scheduleExecution(addToQueue, store);
  var triggerExecution = match[1];
  var immediateEffects = List.filter(Effect$ReduxSerialEffects.isImmediateEffect)(effects);
  var queuedEffects = List.filter(Effect$ReduxSerialEffects.isQueuedEffect)(effects);
  var match$1 = runImmediateEffects(store, immediateEffects);
  if (match$1.tag) {
    Curry._1(triggerExecution, /* [] */0);
    return /* Error */Block.__(1, [match$1[0]]);
  } else {
    Curry._1(triggerExecution, queuedEffects);
    return /* Ok */Block.__(0, [match[0]]);
  }
}

function create(param) {
  var match = Subscribers$ReduxSerialEffects.create(/* () */0);
  var callSubscribers = match[1];
  var match$1 = PromiseQueue$ReduxSerialEffects.create(/* () */0);
  var addToQueue = match$1[0];
  var middleware = function (store, next, action) {
    var fromState = store.getState();
    var result = Curry._1(next, action);
    var toState = store.getState();
    if (fromState !== toState) {
      var transition = Transition$ReduxSerialEffects.create(fromState, toState);
      var issuedEffects = Result$ReduxSerialEffects.sequence(Curry._1(callSubscribers, transition));
      if (issuedEffects.tag) {
        return /* EffectsError */Block.__(1, [issuedEffects[0]]);
      } else {
        var result$1 = queueAndRunEffects(addToQueue, store, issuedEffects[0]);
        if (result$1.tag) {
          return /* EffectsError */Block.__(1, [result$1[0]]);
        } else {
          return /* EffectsSuccess */Block.__(0, [result$1[0]]);
        }
      }
    } else {
      return /* NoChange */Block.__(2, [result]);
    }
  };
  return /* tuple */[
          middleware,
          match[0],
          match$1[1]
        ];
}

exports.dispatchResultAction = dispatchResultAction;
exports.executeEffect = executeEffect;
exports.getFirstRunResultErrorIfExists = getFirstRunResultErrorIfExists;
exports.runImmediateEffects = runImmediateEffects;
exports.executeQueuedEffects = executeQueuedEffects;
exports.scheduleExecution = scheduleExecution;
exports.queueAndRunEffects = queueAndRunEffects;
exports.create = create;
/* Repromise Not a pure module */
